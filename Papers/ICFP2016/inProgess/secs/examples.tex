\section{Motivating Examples} 
\label{examples}

With next few illustrative examples we show functionality of \ourTool/.

\subsection{Synthesis with the standard library}

%introduction to us using stutter- from the ground up
We start with a \codeinline{stutter} program, which is one of canonical 
programs used in 

As an introduction to \ourTool/, imagine that a user wants to synthesis a \codeinline{stutter} program that duplicates each element of a list. 
The user will begin by providing a list of examples as a list of input/output pairs to the special variable \codeinline{exs}.
This tool is embedded in Haskell, so examples use regular Haskell syntax along with a type annotation.

\begin{lstlisting}
exs :: [([Int], [Int])]
exs = [([1, 2, 3], [1, 1, 2, 2, 3, 3])]
\end{lstlisting}

Calling \ourTool/ on this file will then begin returning satisfying programs.
Using a type-directed enumeration, we look for programs fitting the example type.
First we look for first order functions of type \codeinline{[Int]->[Int]}.
We can also look for generalizations of that type, such as \codeinline{[a]->[a]}, or \codeinline{Num a => [a]->[a]}.
Some functions like this will be \codeinline{cycle} or \codeinline{tail} - which will not satisfy these examples.
Once we have exhausted this class of functions, we begin searching for chains of application.
In particular, we focus on higher order functions because they result in more interesting programs and are more challenging.

One higher order function of interest is in the Haskell the standard library; \codeinline{concatMap :: (a -> [b]) -> [a] -> [b]} which applies a function over a list and concatenates the result.
With \codeinline{concatMap} as a candidate higher order function, we can now search for a component first order function of type \codeinline{a -> [b]}.
We will not find a useful function of such a type, and need to continue searching for generalizations of that type.
We will find the function \codeinline{replicate n :: Int -> a -> [a]} in the standard library, which will replicate an item n times into a list.
This function only needs to be specialized to our examples by applying an initial value.

In the end, \ourTool/ only requires a single example to synthesize the program \codeinline{concatMap (replicate 2)}.
If however, in addition to the above example, the user provided a function \codeinline{dupl} which duplicates an element, there is now a second possible solution to the synthesis.
Rather waiting to find all solutions, \ourTool/ returns solutions to the user as they are found, then proceeds with rest of the search.
For this example, \ourTool/ will return the solution \codeinline{concatMap dupl} after X seconds, continue searching and return \codeinline{concatMap (replicate 2)} after X+Y seconds.

\begin{lstlisting}
dupl :: a -> [a]
dupl x = [x,x]
\end{lstlisting}

In order to return better solutions in the beginning of the search, we use a ranking system based on the complexity of the generated programs.
We introduce a new complexity measure called \textit{naturalness} to help guide our search.
Naturalness will also help us avoid the difficult to read solutions as those often seen in other programming-by-example systems.

If programming-by-example is to be integrated into mainstream programming environments, the generated code must be readable and editable.
The code should also support a real language and use native datatypes to the language.
While in MYTH~\cite{Osera:2015} the focus was on lists as inductively defined data types, we are focusing on using the built in representation of a list in Haskell.

\subsection{Optimizing with types}

If in our search, we look for every function of the correct type, we quickly explore the search space.
By using information embedded in the examples, we can infer refinement types to help prune the space.
Take the example of synthesizing a function that takes the odd numbers from a list.
Again, only a single example is needed for \ourTool/ to find a simple solution program.

\begin{lstlisting}
exs :: [([Int], [Int])]
exs = [([1, 2, 3], [1,3])]
\end{lstlisting}

Rather then beginning a search over all functions of type \codeinline{[Int] -> [Int]}, we can first infer a refinement type.
This refinement type will specify that the input must be at longer than the output.
\ourTool/ then searches for a higher order function consistent with this refinement type.
For simplicity, imagine we only have the higher order functions \codeinline{map} and \codeinline{filter} available.
\codeinline{map} will be assigned a refinement type that specifies the input and output lengths are equal - however is pruned from the search since this observation is not consistent with the example's refinement type.
\codeinline{filter} will be assigned a refinement type that specifies the input length is greater than or equal to the output length.
This observation is consistent with the examples, and is thus used to synthesize the solution \codeinline{filter (odd)}.


\subsection{Synthesis with user defined values}

Working on a set of user defined code is also a critical task \ourTool/ supports. 
In the next example the user has provided a binary tree data structure and a higher order function to map over it. We show the synthesis of the exceedingly (for the sake of brevity) simple program \codeinline{mapBTree not}.
Doing such synthesis requires automatic reasoning about not only the user defined polymorphic data type, but also the higher order function they have defined over it.

\begin{lstlisting}
data BTree a = Nil |
               Branch (BTree a) a (BTree a)

mapBTree :: (a -> a) -> BTree a -> BTree 
mapBTree f Nil = Nil
mapBTree f (Branch b1 v b2) = 
  Branch (mapBTree f b1) (f v) (mapBTree f b2)

exs :: [(BTree Bool, Tree Bool)]
exs = [(Branch Nil True Nil,
       Branch Nil False Nil)]
\end{lstlisting}

It may seem that if a user can write a higher order functions over custom data structures, they would not have a need to synthesize such functions.
However, imagine the case of a user importing libraries.
Haskell's module system and large repository of libraries like Hackage and Stackage are an indispensable part of the language\cite{hackage,stackage}.
Often, a user is importing a library that is large, unfamiliar, and/or poorly documented.
Using \ourTool/, the user no longer needs an intimate knowledge of the library to makes use of the functions and datatypes, and can instead synthesize functions from examples.


\subsection{Synthesis with a DSL}

As an example, we show code to transpose a music value from the Euterpea DSL (domain specific library) for music\cite{euterpea}.
Among other things, Euterpea defines a tree-like datatype called \codeinline{Music} and various functions for manipulating these types.
The user only needs to express the basic datatype as examples, and \ourTool/ can synthesize the \codeinline{solution} program.
The solution utilizes the functions from Euterpea; \codeinline{mMap} for mapping over music values, and \codeinline{(trans::Int -> Music Pitch->Music Pitch)} to transpose a Music Pitch by a value.
This again requires automated reasoning about the properties of the library's data types and higher order functions.
Because we have synthesized a natural looking program, the user does not need to understand details of the library's function and data structures to be able to immediately gain an intuition about how the solution program works.

\begin{lstlisting}
import Euterpea

exs :: [(Music Pitch, Music Pitch)]
exs = [
  (Prim (Note qn (C,4)):+:Prim (Note qn (D,4)),
   Prim (Note qn (D,4)):+:Prim (Note qn (E,4))) ]
        
solution = mMap (trans 2)
\end{lstlisting}

