%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{amsmath}
\usepackage{listings}
\usepackage{xspace}
\input{defs}
\usepackage{tikz}



\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Natural Program Synthesis from Examples in Haskell}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
  We present a method for programming-by-example in a language that supports a full range of higher-order functions.
  This modular synthesis algorithm seperates higher order and first order function synthesis.
  Given a set of input-output examples, our method first selects the best fitting, potential higher-order functions.
  Combined with a simple, type-directed first order synthesis procedure, we can generate full, easy to read, programs.

  We use a \textit{dismantling} technique to infer refinement types over candidate higher-order functions.
  Then, we infer a set of potential refinement types over the input-output examples.
  Merging these two sets gives a ranked list of suitable higher-order functions.
  Using refinement types frees us from the need for restrictive templating, allowing us to use full libraries in our synthesis procedure.
  To complete the synthesis, we use a best-first enumerative search based on a weighted subtyping to remove the need for subexample generation, which would rely on further templating.

  We implement this approach in \ourTool/ against a set of synthesis examples including lists, trees, maps, and specialized musical score data structures.
  The synthesized programs operate over datastructures and draw functions from various real world Haskell packages.
  This evaluation demonstrates the scalability and versatility of this approach.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2




\input{intro}

\input{examples}

\input{problem}

\input{overview}

\input{offline}

\section{Online: Fitting Functions to Examples} \label{synth}
\input{online0}

\section{Evaluation}\label{evaluation}
\input{eval}

\input{related}

\input{conclusion}

\bibliographystyle{abbrvnat}
\bibliography{myBib}


\end{document}
