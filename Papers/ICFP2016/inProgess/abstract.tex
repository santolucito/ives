\begin{abstract}
 
Programming by example is a popular paradigm used in software synthesis. The user provides a set of input-output examples that should illustrate her intentions, and a synthesis engine should automatically generate a program that satisfies these examples. However, often it is the case that the return code is very complex and unreadable, although it is correct. We propose a
synthesis approach that generates  full, easy to read Haskell programs. Our tool finds best fitting, potentially higher order functions. The returned program utilizes Haskell libraries as well as user defined functions. Our algorithm incrementally aims to construct values that are considered "most natural" first.  We use refinement types to help us prune the search space of all programs.   Something else here???


We implement this approach in \ourTool/ and we evaluate it on  set of synthesis examples including lists, trees, maps, and specialized musical score data structures. The synthesized programs operate over data structures and draw functions from various real world Haskell packages. The evaluation demonstrates the scalability and versatility of this approach. 
 
\end{abstract}
